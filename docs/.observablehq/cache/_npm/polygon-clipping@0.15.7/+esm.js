/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/polygon-clipping@0.15.7/dist/polygon-clipping.esm.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import t from"../splaytree@3.1.2/+esm.js";import{orient2d as e}from"../robust-predicates@3.0.2/+esm.js";var n="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};function i(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}var s=i,o=r;function l(t){if(s===setTimeout)return setTimeout(t,0);if((s===i||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(e){try{return s.call(null,t,0)}catch(e){return s.call(this,t,0)}}}"function"==typeof n.setTimeout&&(s=setTimeout),"function"==typeof n.clearTimeout&&(o=clearTimeout);var h,u=[],c=!1,f=-1;function p(){c&&h&&(c=!1,h.length?u=h.concat(u):f=-1,u.length&&g())}function g(){if(!c){var t=l(p);c=!0;for(var e=u.length;e;){for(h=u,u=[];++f<e;)h&&h[f].run();f=-1,e=u.length}h=null,c=!1,function(t){if(o===clearTimeout)return clearTimeout(t);if((o===r||!o)&&clearTimeout)return o=clearTimeout,clearTimeout(t);try{return o(t)}catch(e){try{return o.call(null,t)}catch(e){return o.call(this,t)}}}(t)}}function y(t,e){this.fun=t,this.array=e}y.prototype.run=function(){this.fun.apply(null,this.array)};function x(){}var a=x,m=x,b=x,E=x,d=x,v=x,S=x;var w=n.performance||{},R=w.now||w.mozNow||w.msNow||w.oNow||w.webkitNow||function(){return(new Date).getTime()};var I=new Date;var _={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];u.push(new y(t,e)),1!==u.length||c||l(g)},title:"browser",browser:!0,env:{},argv:[],version:"",versions:{},on:a,addListener:m,once:b,off:E,removeListener:d,removeAllListeners:v,emit:S,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*R.call(w),n=Math.floor(e),i=Math.floor(e%1*1e9);return t&&(n-=t[0],(i-=t[1])<0&&(n--,i+=1e9)),[n,i]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-I)/1e3}};const P=(t,e)=>t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y,k=(t,e)=>{if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;const n=t.ll.x<e.ll.x?e.ll.x:t.ll.x,i=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:i,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}};let T=Number.EPSILON;void 0===T&&(T=Math.pow(2,-52));const A=T*T,N=(t,e)=>{if(-T<t&&t<T&&-T<e&&e<T)return 0;const n=t-e;return n*n<A*t*e?0:t<e?-1:1};class L{constructor(){this.tree=new t,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(null!==n&&0===N(e.key,n.key))return this.tree.remove(t),n.key;const i=this.tree.next(e);return null!==i&&0===N(e.key,i.key)?(this.tree.remove(t),i.key):t}}const O=new class{constructor(){this.reset()}reset(){this.xRounder=new L,this.yRounder=new L}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}},$=(t,e)=>t.x*e.y-t.y*e.x,B=(t,e)=>t.x*e.x+t.y*e.y,M=(t,n,i)=>{const r=e(t.x,t.y,n.x,n.y,i.x,i.y);return r>0?-1:r<0?1:0},G=t=>Math.sqrt(B(t,t)),q=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},r={x:n.x-t.x,y:n.y-t.y};return $(r,i)/G(r)/G(i)},z=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},r={x:n.x-t.x,y:n.y-t.y};return B(r,i)/G(r)/G(i)},C=(t,e,n)=>0===e.y?null:{x:t.x+e.x/e.y*(n-t.y),y:n},F=(t,e,n)=>0===e.x?null:{x:n,y:t.y+e.y/e.x*(n-t.x)};class U{static compare(t,e){const n=U.comparePoints(t.point,e.point);return 0!==n?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:V.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){void 0===t.events?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.point.events.push(n),n.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(void 0===n.segment.consumedBy)for(let i=e+1;i<t;i++){const t=this.point.events[i];void 0===t.consumedBy&&(n.otherSE.point.events===t.otherSE.point.events&&n.segment.consume(t.segment))}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,n=n=>{const i=n.otherSE;e.set(n,{sine:q(this.point,t.point,i.point),cosine:z(this.point,t.point,i.point)})};return(t,i)=>{e.has(t)||n(t),e.has(i)||n(i);const{sine:r,cosine:s}=e.get(t),{sine:o,cosine:l}=e.get(i);return r>=0&&o>=0?s<l?1:s>l?-1:0:r<0&&o<0?s<l?-1:s>l?1:0:o<r?-1:o>r?1:0}}}let Y=0;class V{static compare(t,e){const n=t.leftSE.point.x,i=e.leftSE.point.x,r=t.rightSE.point.x,s=e.rightSE.point.x;if(s<n)return 1;if(r<i)return-1;const o=t.leftSE.point.y,l=e.leftSE.point.y,h=t.rightSE.point.y,u=e.rightSE.point.y;if(n<i){if(l<o&&l<h)return 1;if(l>o&&l>h)return-1;const n=t.comparePoint(e.leftSE.point);if(n<0)return 1;if(n>0)return-1;const i=e.comparePoint(t.rightSE.point);return 0!==i?i:-1}if(n>i){if(o<l&&o<u)return-1;if(o>l&&o>u)return 1;const n=e.comparePoint(t.leftSE.point);if(0!==n)return n;const i=t.comparePoint(e.rightSE.point);return i<0?1:i>0?-1:1}if(o<l)return-1;if(o>l)return 1;if(r<s){const n=e.comparePoint(t.rightSE.point);if(0!==n)return n}if(r>s){const n=t.comparePoint(e.rightSE.point);if(n<0)return 1;if(n>0)return-1}if(r!==s){const t=h-o,e=r-n,c=u-l,f=s-i;if(t>e&&c<f)return 1;if(t<e&&c>f)return-1}return r>s?1:r<s||h<u?-1:h>u?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,i){this.id=++Y,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=i}static fromRing(t,e,n){let i,r,s;const o=U.comparePoints(t,e);if(o<0)i=t,r=e,s=1;else{if(!(o>0))throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);i=e,r=t,s=-1}const l=new U(i,!0),h=new U(r,!1);return new V(l,h,[n],[s])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,i=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const r=(t.y-e.y)/i.y,s=e.x+r*i.x;if(t.x===s)return 0;const o=(t.x-e.x)/i.x,l=e.y+o*i.y;return t.y===l?0:t.y<l?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),i=k(e,n);if(null===i)return null;const r=this.leftSE.point,s=this.rightSE.point,o=t.leftSE.point,l=t.rightSE.point,h=P(e,o)&&0===this.comparePoint(o),u=P(n,r)&&0===t.comparePoint(r),c=P(e,l)&&0===this.comparePoint(l),f=P(n,s)&&0===t.comparePoint(s);if(u&&h)return f&&!c?s:!f&&c?l:null;if(u)return c&&r.x===l.x&&r.y===l.y?null:r;if(h)return f&&s.x===o.x&&s.y===o.y?null:o;if(f&&c)return null;if(f)return s;if(c)return l;const p=((t,e,n,i)=>{if(0===e.x)return F(n,i,t.x);if(0===i.x)return F(t,e,n.x);if(0===e.y)return C(n,i,t.y);if(0===i.y)return C(t,e,n.y);const r=$(e,i);if(0==r)return null;const s={x:n.x-t.x,y:n.y-t.y},o=$(s,e)/r,l=$(s,i)/r;return{x:(t.x+l*e.x+(n.x+o*i.x))/2,y:(t.y+l*e.y+(n.y+o*i.y))/2}})(r,this.vector(),o,t.vector());return null===p?null:P(i,p)?O.round(p.x,p.y):null}split(t){const e=[],n=void 0!==t.events,i=new U(t,!0),r=new U(t,!1),s=this.rightSE;this.replaceRightSE(r),e.push(r),e.push(i);const o=new V(i,s,this.rings.slice(),this.windings.slice());return U.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),U.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(i.checkForConsuming(),r.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let t=0,e=this.windings.length;t<e;t++)this.windings[t]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const i=V.compare(e,n);if(0!==i){if(i>0){const t=e;e=n,n=t}if(e.prev===n){const t=e;e=n,n=t}for(let t=0,i=n.rings.length;t<i;t++){const i=n.rings[t],r=n.windings[t],s=e.rings.indexOf(i);-1===s?(e.rings.push(i),e.windings.push(r)):e.windings[s]+=r}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}beforeState(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,i=this._afterState.multiPolys;for(let t=0,i=this.rings.length;t<i;t++){const i=this.rings[t],r=this.windings[t],s=e.indexOf(i);-1===s?(e.push(i),n.push(r)):n[s]+=r}const r=[],s=[];for(let t=0,i=e.length;t<i;t++){if(0===n[t])continue;const i=e[t],o=i.poly;if(-1===s.indexOf(o))if(i.isExterior)r.push(o);else{-1===s.indexOf(o)&&s.push(o);const t=r.indexOf(i.poly);-1!==t&&r.splice(t,1)}}for(let t=0,e=r.length;t<e;t++){const e=r[t].multiPoly;-1===i.indexOf(e)&&i.push(e)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(tt.type){case"union":{const n=0===t.length,i=0===e.length;this._isInResult=n!==i;break}case"intersection":{let n,i;t.length<e.length?(n=t.length,i=e.length):(n=e.length,i=t.length),this._isInResult=i===tt.numMultiPolys&&n<i;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2==1;break}case"difference":{const n=t=>1===t.length&&t[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${tt.type}`)}return this._isInResult}}class D{constructor(t,e,n){if(!Array.isArray(t)||0===t.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],"number"!=typeof t[0][0]||"number"!=typeof t[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const i=O.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};let r=i;for(let e=1,n=t.length;e<n;e++){if("number"!=typeof t[e][0]||"number"!=typeof t[e][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let n=O.round(t[e][0],t[e][1]);n.x===r.x&&n.y===r.y||(this.segments.push(V.fromRing(r,n,this)),n.x<this.bbox.ll.x&&(this.bbox.ll.x=n.x),n.y<this.bbox.ll.y&&(this.bbox.ll.y=n.y),n.x>this.bbox.ur.x&&(this.bbox.ur.x=n.x),n.y>this.bbox.ur.y&&(this.bbox.ur.y=n.y),r=n)}i.x===r.x&&i.y===r.y||this.segments.push(V.fromRing(r,i,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}class j{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new D(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let e=1,n=t.length;e<n;e++){const n=new D(t[e],this,!1);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.interiorRings.push(n)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class X{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof t[0][0][0]&&(t=[t])}catch(t){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let e=0,n=t.length;e<n;e++){const n=new j(t[e],this);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.polys.push(n)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class Q{static factory(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.isInResult()||i.ringOut)continue;let r=null,s=i.leftSE,o=i.rightSE;const l=[s],h=s.point,u=[];for(;r=s,s=o,l.push(s),s.point!==h;)for(;;){const t=s.getAvailableLinkedEvents();if(0===t.length){const t=l[0].point,e=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${t.x}, ${t.y}]. Last matching segment found ends at [${e.x}, ${e.y}].`)}if(1===t.length){o=t[0].otherSE;break}let n=null;for(let t=0,e=u.length;t<e;t++)if(u[t].point===s.point){n=t;break}if(null!==n){const t=u.splice(n)[0],i=l.splice(t.index);i.unshift(i[0].otherSE),e.push(new Q(i.reverse()));continue}u.push({index:l.length,point:s.point});const i=s.getLeftmostComparator(r);o=t.sort(i)[0].otherSE;break}e.push(new Q(l))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let n=1,i=this.events.length-1;n<i;n++){const i=this.events[n].point,r=this.events[n+1].point;0!==M(i,t,r)&&(e.push(i),t=i)}if(1===e.length)return null;const n=e[0],i=e[1];0===M(n,t,i)&&e.shift(),e.push(e[0]);const r=this.isExteriorRing()?1:-1,s=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,l=[];for(let t=s;t!=o;t+=r)l.push([e[t].x,e[t].y]);return l}isExteriorRing(){if(void 0===this._isExteriorRing){const t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let e=1,n=this.events.length;e<n;e++){const n=this.events[e];U.compare(t,n)>0&&(t=n)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class W{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}class Z{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}_composePolys(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new W(i));else{const t=i.enclosingRing();t.poly||e.push(new W(t)),t.poly.addInterior(i)}}return e}}class H{constructor(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.compare;this.queue=e,this.tree=new t(n),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const i=t.isLeft?this.tree.add(e):this.tree.find(e);if(!i)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let r,s,o=i,l=i;for(;void 0===r;)o=this.tree.prev(o),null===o?r=null:void 0===o.key.consumedBy&&(r=o.key);for(;void 0===s;)l=this.tree.next(l),null===l?s=null:void 0===l.key.consumedBy&&(s=l.key);if(t.isLeft){let i=null;if(r){const t=r.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(i=t),!r.isAnEndpoint(t))){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}let o=null;if(s){const t=s.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(o=t),!s.isAnEndpoint(t))){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}if(null!==i||null!==o){let t=null;if(null===i)t=o;else if(null===o)t=i;else{t=U.comparePoints(i,o)<=0?i:o}this.queue.remove(e.rightSE),n.push(e.rightSE);const r=e.split(t);for(let t=0,e=r.length;t<e;t++)n.push(r[t])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=r)}else{if(r&&s){const t=r.getIntersection(s);if(null!==t){if(!r.isAnEndpoint(t)){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}if(!s.isAnEndpoint(t)){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const i=t.split(e);return i.push(n),void 0===t.consumedBy&&this.tree.add(t),i}}const J=void 0!==_&&_.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,K=void 0!==_&&_.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;const tt=new class{run(e,n,i){tt.type=e,O.reset();const r=[new X(n,!0)];for(let t=0,e=i.length;t<e;t++)r.push(new X(i[t],!1));if(tt.numMultiPolys=r.length,"difference"===tt.type){const t=r[0];let e=1;for(;e<r.length;)null!==k(r[e].bbox,t.bbox)?e++:r.splice(e,1)}if("intersection"===tt.type)for(let t=0,e=r.length;t<e;t++){const e=r[t];for(let n=t+1,i=r.length;n<i;n++)if(null===k(e.bbox,r[n].bbox))return[]}const s=new t(U.compare);for(let t=0,e=r.length;t<e;t++){const e=r[t].getSweepEvents();for(let t=0,n=e.length;t<n;t++)if(s.insert(e[t]),s.size>J)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const o=new H(s);let l=s.size,h=s.pop();for(;h;){const t=h.key;if(s.size===l){const e=t.segment;throw new Error(`Unable to pop() ${t.isLeft?"left":"right"} SweepEvent [${t.point.x}, ${t.point.y}] from segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] from queue.`)}if(s.size>J)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(o.segments.length>K)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const e=o.process(t);for(let t=0,n=e.length;t<n;t++){const n=e[t];void 0===n.consumedBy&&s.insert(n)}l=s.size,h=s.pop()}O.reset();const u=Q.factory(o.segments);return new Z(u).getGeom()}};var et={union:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return tt.run("union",t,n)},intersection:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return tt.run("intersection",t,n)},xor:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return tt.run("xor",t,n)},difference:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return tt.run("difference",t,n)}};export{et as default};
