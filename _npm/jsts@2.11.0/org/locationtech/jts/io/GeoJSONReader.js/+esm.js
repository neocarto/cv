/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/jsts@2.11.0/org/locationtech/jts/io/GeoJSONReader.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function t(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class e{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class n extends Error{constructor(t){super(t),this.name=Object.keys({Exception:n})[0]}toString(){return this.message}}class i extends n{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:i})[0]}}class s{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function r(){}function o(){}function l(){}r.NaN=NaN,r.isNaN=t=>Number.isNaN(t),r.isInfinite=t=>!Number.isFinite(t),r.MAX_VALUE=Number.MAX_VALUE,r.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,r.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);r.doubleToLongBits=function(i){e[0]=i;let r=0|n[0],o=0|n[1];return(o&t)===t&&0!=(1048575&o)&&0!==r&&(r=0,o=2146959360),new s(o,r)},r.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=1023,e=Math.log2,n=Math.floor,i=Math.pow,o=function(){for(let t=53;t>0;t--){const s=i(2,t)-1;if(n(e(s))+1===t)return s}return 0}();r.doubleToLongBits=function(r){let l,a,h,c,u,g,f,y,_;if(r<0||1/r===Number.NEGATIVE_INFINITY?(g=1<<31,r=-r):g=0,0===r)return _=0,y=g,new s(y,_);if(r===1/0)return _=0,y=2146435072|g,new s(y,_);if(r!=r)return _=0,y=2146959360,new s(y,_);if(c=0,_=0,l=n(r),l>1)if(l<=o)c=n(e(l)),c<=20?(_=0,y=l<<20-c&1048575):(h=c-20,a=i(2,h),_=l%a<<32-h,y=l/a&1048575);else for(h=l,_=0;a=h/2,h=n(a),0!==h;)c++,_>>>=1,_|=(1&y)<<31,y>>>=1,a!==h&&(y|=524288);if(f=c+t,u=0===l,l=r-l,c<52&&0!==l)for(h=0;;){if(a=2*l,a>=1?(l=a-1,u?(f--,u=!1):(h<<=1,h|=1,c++)):(l=a,u?0==--f&&(c++,u=!1):(h<<=1,c++)),20===c)y|=h,h=0;else if(52===c){_|=h;break}if(1===a){c<20?y|=h<<20-c:c<52&&(_|=h<<52-c);break}}return y|=f<<20,y|=g,new s(y,_)},r.longBitsToDouble=function(e){let n,s,r,o;const l=e.high,a=e.low,h=l&1<<31?-1:1;for(r=((2146435072&l)>>20)-t,o=0,s=1<<19,n=1;n<=20;n++)l&s&&(o+=i(2,-n)),s>>>=1;for(s=1<<31,n=21;n<=52;n++)a&s&&(o+=i(2,-n)),s>>>=1;if(-1023===r){if(0===o)return 0*h;r=-1022}else{if(1024===r)return 0===o?h/0:NaN;o+=1}return h*o*i(2,r)}}();class a extends n{constructor(t){super(t),this.name=Object.keys({RuntimeException:a})[0]}}class h extends a{constructor(){super(),h.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)a.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];a.constructor_.call(this,t)}}}class c{static isTrue(){if(1===arguments.length){const t=arguments[0];c.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new h:new h(t)}}static shouldNeverReachHere(){if(0===arguments.length)c.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new h("Should never reach here"+(null!==t?": "+t:""))}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];c.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new h("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}function u(){}function g(){}const f=new ArrayBuffer(8),y=new Float64Array(f),_=new Int32Array(f);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return y[0]=t,_[0]^_[1]}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}setM(t){throw new i("Invalid ordinate index: "+m.M)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||r.isNaN(this.getZ())&&r.isNaN(t.getZ()))}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,i=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+i*i)}getY(){return this.y}getM(){return r.NaN}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.setZ(e);break;default:throw new i("Invalid ordinate index: "+t)}}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new i("Invalid ordinate index: "+t)}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.getZ(),t.getZ(),n)}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return c.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,u,l]}}class p{constructor(){p.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)p.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0}compare(t,e){const n=p.compare(t.x,e.x);if(0!==n)return n;const i=p.compare(t.y,e.y);if(0!==i)return i;if(this._dimensionsToTest<=2)return 0;return p.compare(t.getZ(),e.getZ())}get interfaces_(){return[g]}}m.DimensionalComparator=p,m.NULL_ORDINATE=r.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class d{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const i=new m;t.getCoordinate(0,i);let s=i.x,r=i.y;for(let o=1;o<e;o++){t.getCoordinate(o,i);const e=i.x,l=i.y,a=e-s,h=l-r;n+=Math.sqrt(a*a+h*h),s=e,r=l}return n}}class x{filter(t){}}class N extends n{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:N})[0]}}class E{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class C extends n{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:C})[0]}}class w extends E{get(){}set(){}isEmpty(){}}class T extends n{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:T})[0]}}class M extends w{constructor(t){super(),this.array=[],t instanceof E&&this.addAll(t)}get interfaces_(){return[w,E]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new I(this)}get(t){if(t<0||t>=this.size())throw new C;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}class I{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new T;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}}class S extends M{constructor(){super(),S.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&t(arguments[0],E)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}toCoordinateArray(){if(0===arguments.length)return this.toArray(S.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(S.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=1;n>i&&(s=-1);for(let r=n;r!==i;r+=s)this.add(t[r],e);return!0}}}S.coordArrayType=new Array(0).fill(null);class A extends m{constructor(){super(),A.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case A.X:this.x=e;break;case A.Y:this.y=e;break;default:throw new i("Invalid ordinate index: "+t)}}setZ(t){throw new i("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new A(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case A.X:return this.x;case A.Y:return this.y}throw new i("Invalid ordinate index: "+t)}}A.X=0,A.Y=1,A.Z=-1,A.M=-1;class O extends m{constructor(){super(),O.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];m.constructor_.call(this,t,e,m.NULL_ORDINATE),this._m=n}}setM(t){this._m=t}setZ(t){throw new i("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new O(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}getM(){return this._m}setOrdinate(t,e){switch(t){case O.X:this.x=e;break;case O.Y:this.y=e;break;case O.M:this._m=e;break;default:throw new i("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case O.X:return this.x;case O.Y:return this.y;case O.M:return this._m}throw new i("Invalid ordinate index: "+t)}}O.X=0,O.Y=1,O.Z=-1,O.M=2;class L extends m{constructor(){super(),L.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof L){const t=arguments[0];m.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];m.constructor_.call(this,t,e,n),this._m=i}}setM(t){this._m=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new i("Invalid ordinate index: "+t)}copy(){return new L(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}getM(){return this._m}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.z=e;break;case m.M:this._m=e;break;default:throw new i("Invalid ordinate index: "+t)}}}class P{static measures(t){return t instanceof A?0:t instanceof O||t instanceof L?1:0}static create(){if(1===arguments.length){const t=arguments[0];return P.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new A:3===t&&0===e?new m:3===t&&1===e?new O:4===t&&1===e?new L:new m}}static dimension(t){return t instanceof A?2:t instanceof O?3:t instanceof L?4:3}}class b{static log10(t){const e=Math.log(t);return r.isInfinite(e)||r.isNaN(e)?e:e/b.LOG_10}static min(t,e,n,i){let s=t;return e<s&&(s=e),n<s&&(s=n),i<s&&(s=i),s}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static average(t,e){return(t+e)/2}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let i=arguments[0];return t>i&&(i=t),e>i&&(i=e),n>i&&(i=n),i}}}b.LOG_10=Math.log(10);class v{static arraycopy(t,e,n,i,s){let r=0;for(let o=e;o<e+s;o++)n[i+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class D{constructor(){D.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof D){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.init(t,e,n,i)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=Math.min(n.x,i.x),r=Math.max(n.x,i.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<s)&&(s=Math.min(n.y,i.y),r=Math.max(n.y,i.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<s)))}}getArea(){return this.getWidth()*this.getHeight()}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof D){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new D(this)}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}hashCode(){let t=17;return t=37*t+m.hashCode(this._minx),t=37*t+m.hashCode(this._maxx),t=37*t+m.hashCode(this._miny),t=37*t+m.hashCode(this._maxy),t}equals(t){if(!(t instanceof D))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new D;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,i=this._maxx<t._maxx?this._maxx:t._maxx,s=this._maxy<t._maxy?this._maxy:t._maxy;return new D(e,i,n,s)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof D){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof D){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<i?(this._miny=n,this._maxy=i):(this._miny=i,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}get interfaces_(){return[o,l]}}class Y{static scroll(t,e){const n=Y.indexOf(e,t);if(n<0)return null;const i=new Array(t.length).fill(null);v.arraycopy(t,n,i,0,t.length-n),v.arraycopy(t,0,i,t.length-n,n),v.arraycopy(i,0,t,0,t.length)}static removeRepeatedPoints(t){if(!Y.hasRepeatedPoints(t))return t;return new S(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++){const n=t[i];t[i]=t[e-i],t[e-i]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let i=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[i++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4];for(let r=0;r<s;r++)n[i+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const i=t[n],s=e[t.length-n-1];if(0!==i.compareTo(s))return!1}return!0}static envelope(t){const e=new D;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static extract(t,e,n){e=b.clamp(e,0,t.length);let i=(n=b.clamp(n,-1,t.length))-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);const s=new Array(i).fill(null);if(0===i)return s;let r=0;for(let i=e;i<=n;i++)s[r++]=t[i];return s}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const i=t[n];if(Y.indexOf(i,e)<0)return i}return null}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(0!==n.compare(t[i],e[i]))return!1;return!0}}static intersection(t,e){const n=new S;for(let i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,P.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static toCoordinateArray(t){return t.toArray(Y.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,P.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}}Y.ForwardComparator=class{compare(t,e){const n=t,i=e;return Y.compare(n,i)}get interfaces_(){return[g]}},Y.BidirectionalComparator=class{compare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=Y.compare(n,i);return Y.isEqualReversed(n,i)?0:s}OLDcompare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=Y.increasingDirection(n),r=Y.increasingDirection(i);let o=s>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(i[l]);if(0!==t)return t;o+=s,l+=r}return 0}get interfaces_(){return[g]}},Y.coordArrayType=new Array(0).fill(null);class R{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class q{static toDimensionSymbol(t){switch(t){case q.FALSE:return q.SYM_FALSE;case q.TRUE:return q.SYM_TRUE;case q.DONTCARE:return q.SYM_DONTCARE;case q.P:return q.SYM_P;case q.L:return q.SYM_L;case q.A:return q.SYM_A}throw new i("Unknown dimension value: "+t)}static toDimensionValue(t){switch(R.toUpperCase(t)){case q.SYM_FALSE:return q.FALSE;case q.SYM_TRUE:return q.TRUE;case q.SYM_DONTCARE:return q.DONTCARE;case q.SYM_P:return q.P;case q.SYM_L:return q.L;case q.SYM_A:return q.A}throw new i("Unknown dimension symbol: "+t)}}q.P=0,q.L=1,q.A=2,q.FALSE=-1,q.TRUE=-2,q.DONTCARE=-3,q.SYM_FALSE="F",q.SYM_TRUE="T",q.SYM_DONTCARE="*",q.SYM_P="0",q.SYM_L="1",q.SYM_A="2";class F{constructor(){F.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===F.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(F.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===F.TYPECODE_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new D(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),i=e.iterator();for(;n.hasNext()&&i.hasNext();){const t=n.next(),e=i.next(),s=t.compareTo(e);if(0!==s)return s}return n.hasNext()?1:i.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[u,o,l]}getClass(){return F}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}F.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},F.TYPECODE_POINT=0,F.TYPECODE_MULTIPOINT=1,F.TYPECODE_LINESTRING=2,F.TYPECODE_LINEARRING=3,F.TYPECODE_MULTILINESTRING=4,F.TYPECODE_POLYGON=5,F.TYPECODE_MULTIPOLYGON=6,F.TYPECODE_GEOMETRYCOLLECTION=7,F.TYPENAME_POINT="Point",F.TYPENAME_MULTIPOINT="MultiPoint",F.TYPENAME_LINESTRING="LineString",F.TYPENAME_LINEARRING="LinearRing",F.TYPENAME_MULTILINESTRING="MultiLineString",F.TYPENAME_POLYGON="Polygon",F.TYPENAME_MULTIPOLYGON="MultiPolygon",F.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",F.geometryChangedFilter={get interfaces_(){return[x]},filter(t){t.geometryChangedAction()}};class G{filter(t){}}class z{}class X{getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return r.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):r.NaN}size(){}getOrdinate(t,e){}get interfaces_(){return[u]}}X.X=0,X.Y=1,X.Z=2,X.M=3;class Z{static scroll(){if(2===arguments.length){if(t(arguments[0],X)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];Z.scroll(t,e,Z.isRing(t))}else if(t(arguments[0],X)&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=Z.indexOf(e,t);if(n<=0)return null;Z.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const i=t.copy(),s=n?t.size()-1:t.size();for(let n=0;n<s;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,i.getOrdinate((e+n)%s,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(s,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const i=Math.min(t.getDimension(),e.getDimension());for(let s=0;s<n;s++)for(let n=0;n<i;n++){const i=t.getOrdinate(s,n),o=e.getOrdinate(s,n);if(t.getOrdinate(s,n)!==e.getOrdinate(s,n)&&(!r.isNaN(i)||!r.isNaN(o)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return Z.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,i=null;for(let s=arguments[1];s<=e;s++){const e=t.getCoordinate(s);(null===i||i.compareTo(e)>0)&&(i=e,n=s)}return n}}static extend(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();if(Z.copy(e,0,i,0,s),s>0)for(let t=s;t<n;t++)Z.copy(e,s-1,i,t,1);return i}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++)Z.swap(t,i,e-i)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return Z.createClosedRing(t,e,4);return e.getOrdinate(0,X.X)===e.getOrdinate(n-1,X.X)&&e.getOrdinate(0,X.Y)===e.getOrdinate(n-1,X.Y)?e:Z.createClosedRing(t,e,n+1)}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const i=t.getCoordinate(n);(null===e||e.compareTo(i)>0)&&(e=i)}return e}static copyCoord(t,e,n,i){const s=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<s;r++)n.setOrdinate(i,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,X.X)===t.getOrdinate(e-1,X.X)&&t.getOrdinate(0,X.Y)===t.getOrdinate(e-1,X.Y))}static swap(t,e,n){if(e===n)return null;for(let i=0;i<t.getDimension();i++){const s=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,s)}}static copy(t,e,n,i,s){for(let r=0;r<s;r++)Z.copyCoord(t,e+r,n,i+r)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,X.X)&&t.y===e.getOrdinate(n,X.Y))return n;return-1}static createClosedRing(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();Z.copy(e,0,i,0,s);for(let t=s;t<n;t++)Z.copy(e,0,i,t,1);return i}}class U{filter(t){}}class k{filter(t,e){}isGeometryChanged(){}isDone(){}}class B extends F{constructor(){super(),B.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];F.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new D:this._points.expandEnvelope(new D)}isRing(){return this.isClosed()&&Y.isRing(this.getCoordinates())}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new B(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return Z.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return F.TYPECODE_LINESTRING}getDimension(){return 1}getBoundary(){throw new N}isEquivalentClass(t){return t instanceof B}getCoordinateSequence(){return this._points}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Z.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?q.FALSE:0}getLength(){return d.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const i=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==i)return i;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(t(arguments[0],G)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(t(arguments[0],k)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(t(arguments[0],U)){arguments[0].filter(this)}else if(t(arguments[0],x)){arguments[0].filter(this)}}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return F.TYPENAME_LINESTRING}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}get interfaces_(){return[z]}}class V extends B{constructor(){super(),V.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];B.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new V(this._points.copy(),this._factory)}getBoundaryDimension(){return q.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return Z.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return F.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<V.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return F.TYPENAME_LINEARRING}}V.MINIMUM_VALID_SIZE=4;class W{create(){if(1===arguments.length)arguments[0]instanceof Array||t(arguments[0],X);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class H{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class j{constructor(){j.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];j.constructor_.call(this,t,Y.dimension(t),Y.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new m}else if(t(arguments[0],X)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];j.constructor_.call(this,t,e,Y.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=P.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return P.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new j(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new H(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getM(t){return this.hasM()?this._coordinates[t].getM():r.NaN}setOrdinate(t,e,n){switch(e){case X.X:this._coordinates[t].x=n;break;case X.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():r.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case X.X:return this._coordinates[t].x;case X.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}get interfaces_(){return[X,l]}}class K{static instance(){return K.instanceObject}readResolve(){return K.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new j(arguments[0])}if(t(arguments[0],X)){return new j(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new j(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new j(arguments[0],e+t,t)}}}get interfaces_(){return[W,l]}}K.instanceObject=new K;class J extends E{contains(){}}class Q extends J{}class $ extends Q{constructor(t){super(),this.array=[],t instanceof E&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new N}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new tt(this.array)}}class tt{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new T;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new N}}class et{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new M;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class nt extends F{constructor(){super(),nt.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(F.constructor_.call(this,e),null===t&&(t=[]),F.hasNullElements(t))throw new i("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new D;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const i=this._geometries[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new nt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this._geometries.length,e=new M(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return F.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getNumGeometries(){return this._geometries.length}getBoundary(){return F.checkNotGeometryCollection(this),c.shouldNeverReachHere(),null}getGeometryType(){return F.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();et.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new $(et.asList(this._geometries)),n=new $(et.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),i=e.getNumGeometries();let s=0;for(;s<n&&s<i;){const n=this.getGeometryN(s),i=e.getGeometryN(s),r=n.compareToSameClass(i,t);if(0!==r)return r;s++}return s<n?1:s<i?-1:0}}apply(){if(t(arguments[0],G)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(t(arguments[0],k)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(t(arguments[0],U)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(t(arguments[0],x)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}}class it{}class st extends nt{constructor(){super(),st.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];nt.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new st(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return F.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new M;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return F.TYPENAME_MULTIPOLYGON}get interfaces_(){return[it]}}class rt{get(){}put(){}size(){}values(){}entrySet(){}}class ot extends J{constructor(t){super(),this.map=new Map,t instanceof E&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new N}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new lt(this.map)}[Symbol.iterator](){return this.map}}class lt{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new T;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new N}}class at{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new at(t)}}class ht{constructor(){ht.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=ht.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ct){const t=arguments[0];this._modelType=t,t===ht.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=ht.FIXED,this.setScale(t)}else if(arguments[0]instanceof ht){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof ht))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return at.compare(n,i)}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===ht.FLOATING?t="Floating":this._modelType===ht.FLOATING_SINGLE?t="Floating-Single":this._modelType===ht.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(r.isNaN(t))return t;if(this._modelType===ht.FLOATING_SINGLE){return t}return this._modelType===ht.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof m){const t=arguments[0];if(this._modelType===ht.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===ht.FLOATING?t=16:this._modelType===ht.FLOATING_SINGLE?t=6:this._modelType===ht.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getScale(){return this._scale}isFloating(){return this._modelType===ht.FLOATING||this._modelType===ht.FLOATING_SINGLE}get interfaces_(){return[l,o]}}class ct{constructor(){ct.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,ct.nameToTypeMap.put(t,this)}readResolve(){return ct.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[l]}}ct.nameToTypeMap=new class extends rt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new M,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new ot;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}},ht.Type=ct,ht.FIXED=new ct("FIXED"),ht.FLOATING=new ct("FLOATING"),ht.FLOATING_SINGLE=new ct("FLOATING SINGLE"),ht.maximumPreciseValue=9007199254740992;class ut extends nt{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];nt.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ut(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?q.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return F.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new N}getGeometryType(){return F.TYPENAME_MULTILINESTRING}get interfaces_(){return[z]}}class gt{}class ft extends n{constructor(t){super(t),this.name=Object.keys({IllegalStateException:ft})[0]}}class yt extends F{constructor(){super(),yt.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];F.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new D;const t=new D;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new yt(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return F.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new ft("getX called on empty Point");return this.getCoordinate().x}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return F.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new ft("getY called on empty Point");return this.getCoordinate().y}isSimple(){return!0}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return q.FALSE}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(t(arguments[0],G)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(t(arguments[0],k)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(t(arguments[0],U)){arguments[0].filter(this)}else if(t(arguments[0],x)){arguments[0].filter(this)}}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),c.isTrue(t.size()<=1),this._coordinates=t}get interfaces_(){return[gt]}}class _t{static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let i=1;i<t.length-1;i++){const s=t[i].x-n,r=t[i+1].y;e+=s*(t[i-1].y-r)}return e/2}if(t(arguments[0],X)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new m,i=new m,s=new m;t.getCoordinate(0,i),t.getCoordinate(1,s);const r=i.x;s.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=i.y,i.x=s.x,i.y=s.y,t.getCoordinate(l+1,s),s.x-=r,o+=i.x*(n.y-s.y);return o/2}}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(_t.ofRingSigned(t))}if(t(arguments[0],X)){const t=arguments[0];return Math.abs(_t.ofRingSigned(t))}}}class mt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class pt{constructor(){pt.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof pt){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];pt.constructor_.call(this,pt.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];return pt.determinant(pt.valueOf(t),pt.valueOf(e),pt.valueOf(n),pt.valueOf(i))}if(arguments[3]instanceof pt&&arguments[2]instanceof pt&&arguments[0]instanceof pt&&arguments[1]instanceof pt){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return pt.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return pt.parse(t)}if("number"==typeof arguments[0]){return new pt(arguments[0])}}static sqrt(t){return pt.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;R.isWhitespace(t.charAt(e));)e++;let i=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(i=!0))}const s=new pt;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,R.isDigit(n)){const t=n-"0";s.selfMultiply(pt.TEN),s.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=at.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let h=s;a||(o=r);const c=r-o-l;if(0===c)h=s;else if(c>0){const t=pt.TEN.pow(c);h=s.divide(t)}else if(c<0){const t=pt.TEN.pow(-c);h=s.multiply(t)}return i?h.negate():h}static createNaN(){return new pt(r.NaN,r.NaN)}static copy(t){return new pt(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let i=Math.trunc(Math.floor(n));return 10*Math.pow(10,i)<=e&&(i+=1),i}static stringOfChar(t,e){const n=new mt;for(let i=0;i<e;i++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),i=pt.magnitude(n._hi);const s=pt.TEN.pow(i);n=n.divide(s),n.gt(pt.TEN)?(n=n.divide(pt.TEN),i+=1):n.lt(pt.ONE)&&(n=n.multiply(pt.TEN),i-=1);const r=i+1,o=new mt,l=pt.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const i=Math.trunc(n._hi);if(i<0)break;let s=!1,a=0;i>9?(s=!0,a="9"):a="0"+i,o.append(a),n=n.subtract(pt.valueOf(i)).multiply(pt.TEN),s&&n.selfAdd(pt.TEN);let h=!0;const c=pt.magnitude(n._hi);if(c<0&&Math.abs(c)>=l-e&&(h=!1),!h)break}return e[0]=i,o.toString()}sqr(){return this.multiply(this)}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}setValue(){if(arguments[0]instanceof pt){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}multiply(){if(arguments[0]instanceof pt){const t=arguments[0];return t.isNaN()?pt.createNaN():pt.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?pt.createNaN():pt.copy(this).selfMultiply(t,0)}}isNaN(){return r.isNaN(this._hi)}reciprocal(){let t=null,e=null,n=null,i=null,s=null,r=null,o=null,l=null;s=1/this._hi,r=pt.SPLIT*s,t=r-s,l=pt.SPLIT*this._hi,t=r-t,e=s-t,n=l-this._hi,o=s*this._hi,n=l-n,i=this._hi-n,l=t*n-o+t*i+e*n+e*i,r=(1-o-l-s*this._lo)/this._hi;const a=s+r;return new pt(a,s-a+r)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof pt){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof pt){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof pt){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof pt){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,h=null;return o=this._hi/t,l=pt.SPLIT*o,n=l-o,h=pt.SPLIT*t,n=l-n,i=o-n,s=h-t,a=o*t,s=h-s,r=t-s,h=n*s-a+n*r+i*s+i*r,l=(this._hi-a-h+this._lo-o*e)/t,h=o+l,this._hi=h,this._lo=o-h+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof pt){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=pt.SPLIT*r,e=o-r,a=pt.SPLIT*t._hi,e=o-e,n=r-e,i=a-t._hi,l=r*t._hi,i=a-i,s=t._hi-i,a=e*i-l+e*s+n*i+n*s,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new pt(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?pt.createNaN():pt.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return pt.valueOf(1);let e=new pt(this),n=pt.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return pt.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new pt(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return pt.valueOf(0);if(this.isNegative())return pt.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=pt.valueOf(e),i=this.subtract(n.sqr())._hi*(.5*t);return n.add(i)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof pt){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null;return i=this._hi+t,r=i-this._hi,s=i-r,s=t-r+(this._hi-s),o=s+this._lo,e=i+o,n=o+(i-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,h=null;o=this._hi+t,s=this._lo+e,a=o-this._hi,h=s-this._lo,l=o-a,r=s-h,l=t-a+(this._hi-l),r=e-h+(this._lo-r),a=l+s,n=o+a,i=a+(o-n),a=r+i;const c=n+a,u=a+(n-c);return this._hi=c,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof pt){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null;o=pt.SPLIT*this._hi,n=o-this._hi,l=pt.SPLIT*t,n=o-n,i=this._hi-n,s=l-t,o=this._hi*t,s=l-s,r=t-s,l=n*s-o+n*r+i*s+i*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const h=l+n;return this._hi=a,this._lo=h,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return pt.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new pt(t,e)}negate(){return this.isNaN()?this:new pt(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}intValue(){return Math.trunc(this._hi)}toString(){const t=pt.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1;let s=n;if("."===n.charAt(0))s="0"+n;else if(i<0)s="0."+pt.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){const t=i-n.length;s=n+pt.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+s:s}toSciNotation(){if(this.isZero())return pt.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=pt.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new ft("Found leading zero: "+n);let s="";n.length>1&&(s=n.substring(1));const r=n.charAt(0)+"."+s;return this.isNegative()?"-"+r+i:r+i}abs(){return this.isNaN()?pt.NaN:this.isNegative()?this.negate():new pt(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof pt){const t=arguments[0];return pt.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return pt.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof pt){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?pt.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[l,o,u]}}pt.PI=new pt(3.141592653589793,12246467991473532e-32),pt.TWO_PI=new pt(6.283185307179586,24492935982947064e-32),pt.PI_2=new pt(1.5707963267948966,6123233995736766e-32),pt.E=new pt(2.718281828459045,14456468917292502e-32),pt.NaN=new pt(r.NaN,r.NaN),pt.EPS=123259516440783e-46,pt.SPLIT=134217729,pt.MAX_PRINT_DIGITS=32,pt.TEN=pt.valueOf(10),pt.ONE=pt.valueOf(1),pt.SCI_NOT_EXPONENT_CHAR="E",pt.SCI_NOT_ZERO="0.0E0";class dt{static orientationIndex(t,e,n){const i=dt.orientationIndexFilter(t,e,n);if(i<=1)return i;const s=pt.valueOf(e.x).selfAdd(-t.x),r=pt.valueOf(e.y).selfAdd(-t.y),o=pt.valueOf(n.x).selfAdd(-e.x),l=pt.valueOf(n.y).selfAdd(-e.y);return s.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof pt&&arguments[2]instanceof pt&&arguments[0]instanceof pt&&arguments[1]instanceof pt){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=pt.valueOf(t),r=pt.valueOf(e),o=pt.valueOf(n),l=pt.valueOf(i);return s.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,i){const s=new pt(t.y).selfSubtract(e.y),o=new pt(e.x).selfSubtract(t.x),l=new pt(t.x).selfMultiply(e.y).selfSubtract(new pt(e.x).selfMultiply(t.y)),a=new pt(n.y).selfSubtract(i.y),h=new pt(i.x).selfSubtract(n.x),c=new pt(n.x).selfMultiply(i.y).selfSubtract(new pt(i.x).selfMultiply(n.y)),u=o.multiply(c).selfSubtract(h.multiply(l)),g=a.multiply(l).selfSubtract(s.multiply(c)),f=s.multiply(h).selfSubtract(a.multiply(o)),y=u.selfDivide(f).doubleValue(),_=g.selfDivide(f).doubleValue();return r.isNaN(y)||r.isInfinite(y)||r.isNaN(_)||r.isInfinite(_)?null:new m(y,_)}static orientationIndexFilter(t,e,n){let i=null;const s=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=s-r;if(s>0){if(r<=0)return dt.signum(o);i=s+r}else{if(!(s<0))return dt.signum(o);if(r>=0)return dt.signum(o);i=-s-r}const l=dt.DP_SAFE_EPSILON*i;return o>=l||-o>=l?dt.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}dt.DP_SAFE_EPSILON=1e-15;class xt{static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],s=0;for(let i=1;i<=e;i++){const e=t[i];e.y>n.y&&(n=e,s=i)}let r=s;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(n)&&r!==s);let o=s;do{o=(o+1)%e}while(t[o].equals2D(n)&&o!==s);const l=t[r],a=t[o];if(l.equals2D(n)||a.equals2D(n)||l.equals2D(a))return!1;const h=xt.index(l,n,a);let c=null;return c=0===h?l.x>a.x:h>0,c}if(t(arguments[0],X)){const t=arguments[0],e=t.size()-1;if(e<3)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),s=0;for(let i=1;i<=e;i++){const e=t.getCoordinate(i);e.y>n.y&&(n=e,s=i)}let r=null,o=s;do{o-=1,o<0&&(o=e),r=t.getCoordinate(o)}while(r.equals2D(n)&&o!==s);let l=null,a=s;do{a=(a+1)%e,l=t.getCoordinate(a)}while(l.equals2D(n)&&a!==s);if(r.equals2D(n)||l.equals2D(n)||r.equals2D(l))return!1;const h=xt.index(r,n,l);let c=null;return c=0===h?r.x>l.x:h>0,c}}static index(t,e,n){return dt.orientationIndex(t,e,n)}}xt.CLOCKWISE=-1,xt.RIGHT=xt.CLOCKWISE,xt.COUNTERCLOCKWISE=1,xt.LEFT=xt.COUNTERCLOCKWISE,xt.COLLINEAR=0,xt.STRAIGHT=xt.COLLINEAR;class Nt extends F{constructor(){super(),Nt.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(F.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),F.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&F.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let i=0;i<n.length;i++)e++,t[e]=n[i];for(let n=0;n<this._holes.length;n++){const i=this._holes[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;t+=_t.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=_t.ofRing(this._holes[e].getCoordinateSequence());return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,i=this._shell,s=n._shell;if(!i.equalsExact(s,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return F.TYPECODE_POLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return F.TYPENAME_POLYGON}getExteriorRing(){return this._shell}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new Nt(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;const s=t.getY(n);if(s!==e.getMinY()&&s!==e.getMaxY())return!1}let n=t.getX(0),i=t.getY(0);for(let e=1;e<=4;e++){const s=t.getX(e),r=t.getY(e);if(s!==n===(r!==i))return!1;n=s,i=r}return!0}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);et.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),i=Z.minCoordinateIndex(n,0,n.size()-2);Z.scroll(n,i,!0),xt.isCCW(n)===e&&Z.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,i=e._shell,s=n.compareToSameClass(i,t);if(0!==s)return s;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),i=e.getInteriorRingN(l),s=n.compareToSameClass(i,t);if(0!==s)return s;l++}return l<r?1:l<o?-1:0}}apply(){if(t(arguments[0],G)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(t(arguments[0],k)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(t(arguments[0],U)){arguments[0].filter(this)}else if(t(arguments[0],x)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[it]}}class Et extends nt{constructor(){super(),Et.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];nt.constructor_.call(this,t,e)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof F){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getTypeCode(){return F.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return F.TYPENAME_MULTIPOINT}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Et(t,this._factory)}isValid(){return!0}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return q.FALSE}get interfaces_(){return[gt]}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ct.constructor_.call(this,new ht,0);else if(1===arguments.length){if(t(arguments[0],W)){const t=arguments[0];Ct.constructor_.call(this,new ht,0,t)}else if(arguments[0]instanceof ht){const t=arguments[0];Ct.constructor_.call(this,t,0,Ct.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ct.constructor_.call(this,t,e,Ct.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return K.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new i("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(t(arguments[0],X)){return new B(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new ut(null,this);if(1===arguments.length){return new ut(arguments[0],this)}}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(t(arguments[0],X)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof V){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new Nt(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new nt(null,this);if(1===arguments.length){return new nt(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(t(arguments[0],X)){return new V(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new st(null,this);if(1===arguments.length){return new st(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new Et(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new Et(arguments[0],this)}if(t(arguments[0],X)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const i=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());Z.copy(t,n,i,0,1),e[n]=this.createPoint(i)}return this.createMultiPoint(e)}}}buildGeometry(t){let e=null,n=!1,i=!1;for(let s=t.iterator();s.hasNext();){const t=s.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof nt&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(Ct.toGeometryArray(t));const s=t.iterator().next();if(t.size()>1){if(s instanceof Nt)return this.createMultiPolygon(Ct.toPolygonArray(t));if(s instanceof B)return this.createMultiLineString(Ct.toLineStringArray(t));if(s instanceof yt)return this.createMultiPoint(Ct.toPointArray(t));c.shouldNeverReachHere("Unhandled geometry type: "+s.getGeometryType())}return s}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(t(arguments[0],X)){return new yt(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}get interfaces_(){return[l]}}const wt=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class Tt{constructor(t){this.geometryFactory=t||new Ct}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Mt[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==wt.indexOf(n)?Mt[n].call(this,e.coordinates):"GeometryCollection"===n?Mt[n].call(this,e.geometries):Mt[n].call(this,e)}write(t){const e=t.getGeometryType();if(!It[e])throw new Error("Geometry is not supported");return It[e].call(this,t)}}const Mt={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Mt[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Mt.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(new m(...i))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new m(t[0],t[1]),new m(t[2],t[1]),new m(t[2],t[3]),new m(t[0],t[3]),new m(t[0],t[1])])},Point:function(t){const e=new m(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Mt.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Mt.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Mt.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Mt.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),i=[];for(let e=1;e<t.length;++e){const n=t[e],s=Mt.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(s);i.push(r)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(Mt.Polygon.call(this,i))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},It={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:It.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=It.Point.call(this,i);e.push(s.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const i=n[t];e.push(It.coordinate.call(this,i))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=It.LineString.call(this,i);e.push(s.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=It.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const i=t._holes[n],s=It.LineString.call(this,i);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=It.Polygon.call(this,i);e.push(s.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=i.getGeometryType();e.push(It[s].call(this,i))}return{type:"GeometryCollection",geometries:e}}};class St{constructor(t){this.parser=new Tt(t||new Ct)}read(t){return this.parser.read(t)}}export{St as default};
