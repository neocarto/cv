import { readFile } from "node:fs/promises";
import { basename, join } from "node:path/posix";
import he from "he";
import MiniSearch from "minisearch";
import { visitMarkdownFiles } from "./files.js";
import { parseMarkdown } from "./markdown.js";
import { faint, strikethrough } from "./tty.js";
const indexCache = /* @__PURE__ */ new WeakMap();
const reindexingDelay = 10 * 60 * 1e3;
const defaultEffects = { logger: console };
const indexOptions = {
  fields: ["title", "text", "keywords"],
  storeFields: ["title"],
  processTerm(term) {
    return term.match(/\p{N}/gu)?.length > 6 ? null : term.slice(0, 15).toLowerCase();
  }
};
async function searchIndex(config, effects = defaultEffects) {
  const { root, pages, search } = config;
  if (!search)
    return "{}";
  if (indexCache.has(config) && indexCache.get(config).freshUntil > +/* @__PURE__ */ new Date())
    return indexCache.get(config).json;
  const pagePaths = /* @__PURE__ */ new Set(["/index"]);
  for (const p of pages) {
    if ("path" in p)
      pagePaths.add(p.path);
    else
      for (const { path } of p.pages)
        pagePaths.add(path);
  }
  const index = new MiniSearch(indexOptions);
  for await (const file of visitMarkdownFiles(root)) {
    const path = join(root, file);
    const source = await readFile(path, "utf8");
    const { html, title, data } = parseMarkdown(source, { root, path: "/" + file.slice(0, -3) });
    const listed = pagePaths.has(`/${file.slice(0, -3)}`);
    const indexed = data?.index === void 0 ? listed : Boolean(data.index);
    if (!indexed) {
      if (listed)
        effects.logger.log(`${faint("index")} ${strikethrough(path)} ${faint("(skipped)")}`);
      continue;
    }
    const id = file.slice(0, basename(file) === "index.md" ? -"index.md".length : -3);
    const text = he.decode(
      html.replaceAll(/[\n\r]/g, " ").replaceAll(/<style\b.*<\/style\b[^>]*>/gi, " ").replaceAll(/<[^>]+>/g, " ")
    ).normalize("NFD").replaceAll(/[\u0300-\u036f]/g, "").replace(/[^\p{L}\p{N}]/gu, " ");
    effects.logger.log(`${faint("index")} ${path}`);
    index.add({ id, title, text, keywords: normalizeKeywords(data?.keywords) });
  }
  const json = JSON.stringify(
    Object.assign(
      {
        options: {
          fields: indexOptions.fields,
          storeFields: indexOptions.storeFields
        }
      },
      index.toJSON()
    )
  );
  indexCache.set(config, { json, freshUntil: +/* @__PURE__ */ new Date() + reindexingDelay });
  return json;
}
function normalizeKeywords(keywords) {
  return keywords ? String(keywords) : "";
}
export {
  searchIndex
};
