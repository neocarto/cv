import { existsSync } from "node:fs";
import { mkdir, readFile, readdir, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path/posix";
import { simple } from "acorn-walk";
import { rsort, satisfies } from "semver";
import { isEnoent } from "./error.js";
import { findImports, isImportMetaResolve } from "./javascript/imports.js";
import { parseProgram } from "./javascript/parse.js";
import { getStringLiteralValue, isStringLiteral } from "./javascript/source.js";
import { relativePath } from "./path.js";
import { Sourcemap } from "./sourcemap.js";
import { faint } from "./tty.js";
function parseNpmSpecifier(specifier) {
  const parts = specifier.split("/");
  const namerange = specifier.startsWith("@") ? [parts.shift(), parts.shift()].join("/") : parts.shift();
  const ranged = namerange.indexOf("@", 1);
  return {
    name: ranged > 0 ? namerange.slice(0, ranged) : namerange,
    range: ranged > 0 ? namerange.slice(ranged + 1) : void 0,
    path: parts.length > 0 ? parts.join("/") : void 0
  };
}
function formatNpmSpecifier({ name, range, path }) {
  return `${name}${range ? `@${range}` : ""}${path ? `/${path}` : ""}`;
}
function rewriteNpmImports(input, path) {
  const body = parseProgram(input);
  const output = new Sourcemap(input);
  simple(body, {
    ImportDeclaration: rewriteImport,
    ImportExpression: rewriteImport,
    ExportAllDeclaration: rewriteImport,
    ExportNamedDeclaration: rewriteImport,
    CallExpression: rewriteImportMetaResolve
  });
  function rewriteImport(node) {
    if (node.source && isStringLiteral(node.source)) {
      rewriteImportSource(node.source);
    }
  }
  function rewriteImportMetaResolve(node) {
    if (isImportMetaResolve(node) && isStringLiteral(node.arguments[0])) {
      rewriteImportSource(node.arguments[0]);
    }
  }
  function rewriteImportSource(source) {
    let value = getStringLiteralValue(source);
    if (value.startsWith("/npm/")) {
      value = `/_npm/${value.slice("/npm/".length)}`;
      if (value.endsWith("/+esm"))
        value += ".js";
      value = relativePath(path, value);
      output.replaceLeft(source.start, source.end, JSON.stringify(value));
    }
  }
  return String(output).replace(/^\/\/# sourceMappingURL=.*$\n?/m, "");
}
const npmRequests = /* @__PURE__ */ new Map();
async function populateNpmCache(root, path) {
  if (!path.startsWith("/_npm/"))
    throw new Error(`invalid npm path: ${path}`);
  const filePath = join(root, ".observablehq", "cache", path);
  if (existsSync(filePath))
    return filePath;
  let promise = npmRequests.get(path);
  if (promise)
    return promise;
  promise = async function() {
    const specifier = resolveNpmSpecifier(path);
    const href = `https://cdn.jsdelivr.net/npm/${specifier}`;
    process.stdout.write(`npm:${specifier} ${faint("\u2192")} `);
    const response = await fetch(href);
    if (!response.ok)
      throw new Error(`unable to fetch: ${href}`);
    process.stdout.write(`${filePath}
`);
    await mkdir(dirname(filePath), { recursive: true });
    if (/^application\/javascript(;|$)/i.test(response.headers.get("content-type"))) {
      await writeFile(filePath, rewriteNpmImports(await response.text(), path), "utf-8");
    } else {
      await writeFile(filePath, Buffer.from(await response.arrayBuffer()));
    }
    return filePath;
  }();
  promise.catch(() => {
  }).then(() => npmRequests.delete(path));
  npmRequests.set(path, promise);
  return promise;
}
let npmVersionCache;
async function initializeNpmVersionCache(root) {
  const cache = /* @__PURE__ */ new Map();
  const cacheDir = join(root, ".observablehq", "cache", "_npm");
  try {
    for (const entry of await readdir(cacheDir)) {
      if (entry.startsWith("@")) {
        for (const subentry of await readdir(join(cacheDir, entry))) {
          const { name, range } = parseNpmSpecifier(`${entry}/${subentry}`);
          const versions = cache.get(name);
          if (versions)
            versions.push(range);
          else
            cache.set(name, [range]);
        }
      } else {
        const { name, range } = parseNpmSpecifier(entry);
        const versions = cache.get(name);
        if (versions)
          versions.push(range);
        else
          cache.set(name, [range]);
      }
    }
  } catch (error) {
    if (!isEnoent(error))
      throw error;
  }
  for (const [key, value] of cache) {
    cache.set(key, rsort(value));
  }
  return cache;
}
const npmVersionRequests = /* @__PURE__ */ new Map();
async function resolveNpmVersion(root, specifier) {
  const { name, range } = specifier;
  if (range && /^\d+\.\d+\.\d+([-+].*)?$/.test(range))
    return range;
  const cache = await (npmVersionCache ??= initializeNpmVersionCache(root));
  const versions = cache.get(specifier.name);
  if (versions) {
    for (const version of versions)
      if (!range || satisfies(version, range))
        return version;
  }
  const href = `https://data.jsdelivr.com/v1/packages/npm/${name}/resolved${range ? `?specifier=${range}` : ""}`;
  let promise = npmVersionRequests.get(href);
  if (promise)
    return promise;
  promise = async function() {
    process.stdout.write(`npm:${formatNpmSpecifier(specifier)} ${faint("\u2192")} `);
    const response = await fetch(href);
    if (!response.ok)
      throw new Error(`unable to fetch: ${href}`);
    const { version } = await response.json();
    if (!version)
      throw new Error(`unable to resolve version: ${formatNpmSpecifier({ name, range })}`);
    const spec = formatNpmSpecifier({ name, range: version });
    process.stdout.write(`npm:${spec}
`);
    cache.set(specifier.name, versions ? rsort(versions.concat(version)) : [version]);
    mkdir(join(root, ".observablehq", "cache", "_npm", spec), { recursive: true });
    return version;
  }();
  promise.catch(() => {
  }).then(() => npmVersionRequests.delete(href));
  npmVersionRequests.set(href, promise);
  return promise;
}
async function resolveNpmImport(root, specifier) {
  const {
    name,
    range = name === "@duckdb/duckdb-wasm" ? "1.28.0" : name === "apache-arrow" ? "13.0.0" : name === "parquet-wasm" ? "0.5.0" : void 0,
    path = name === "mermaid" ? "dist/mermaid.esm.min.mjs/+esm" : name === "echarts" ? "dist/echarts.esm.min.js" : "+esm"
  } = parseNpmSpecifier(specifier);
  return `/_npm/${name}@${await resolveNpmVersion(root, { name, range })}/${path.replace(/\+esm$/, "+esm.js")}`;
}
const npmImportsCache = /* @__PURE__ */ new Map();
async function resolveNpmImports(root, path) {
  if (!path.startsWith("/_npm/"))
    throw new Error(`invalid npm path: ${path}`);
  let promise = npmImportsCache.get(path);
  if (promise)
    return promise;
  promise = async function() {
    try {
      const filePath = await populateNpmCache(root, path);
      if (!/\.(m|c)?js$/i.test(path))
        return [];
      const source = await readFile(filePath, "utf-8");
      const body = parseProgram(source);
      return findImports(body, path, source);
    } catch (error) {
      console.warn(`unable to fetch or parse: ${path}`);
      return [];
    }
  }();
  npmImportsCache.set(path, promise);
  return promise;
}
function resolveNpmSpecifier(path) {
  return path.replace(/^\/_npm\//, "").replace(/\/\+esm\.js$/, "/+esm");
}
export {
  formatNpmSpecifier,
  parseNpmSpecifier,
  populateNpmCache,
  resolveNpmImport,
  resolveNpmImports,
  resolveNpmSpecifier,
  rewriteNpmImports
};
